## Author: Odey John Ebinyi
## Date: Thursday, 11th August, 2022
## Twitter: @i_am_giannis
## Description: K-Nearest Neighbors classifier for Malware & threat analysis using machine
## learning.

import pandas as pd
import seaborn as sb
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report, confusion_matrix

def conf_matrix(knn_clf, x_test, y_test):
    y_pred = knn_clf.predict(x_test)
    
    # annot=True adds numeric values in the heatmap cells. fmt="d" makes heatmap to use decimals when 
    # adding annotations. cmap is the color map which is set to blue. Color bar, cbar, is set to True.
    cf_matrix = sb.heatmap(confusion_matrix(y_pred, y_test), annot = True, fmt="d", cmap=plt.cm.Blues, cbar=True)
    cf_matrix.set_title("Confusion Matrix for KNN")
    cf_matrix.set_xlabel('Predicted Values')
    cf_matrix.set_ylabel('Actual Values')
    
    cf_matrix.xaxis.set_ticklabels(['False', 'True'])
    cf_matrix.yaxis.set_ticklabels(['False', 'True'])
    plt.show()
    
def scale_feature(x_train, x_test):
    standard_scaler = StandardScaler()
    x_train = standard_scaler.fit_transform(x_train) # Fit x_train to data and then transform it
    x_test = standard_scaler.transform(x_test) # transform x_test.

def knn_classification_report(knn_clf, x_test, y_test):
    y_pred = knn_clf.predict(x_test)
    print("*******************Classification Report**********************")
    print(classification_report(y_test, y_pred))
    
def knn_visualize(train_scores, test_scores, k):
    plt.figure(figsize = (12, 5)) # plot figure size of width=12 and height=5 in inches
    p = sb.lineplot(range(1, k), train_scores, marker='*', label='Train Score')
    p = sb.lineplot(range(1, k), test_scores, marker='o', label='Test Score')
    
def knn(train_data_frame):
    # Variable X is given dataset free from malware, while
    # variable y is given dataset with malware.
    X = train_data_frame.drop(['Name', 'Malware'], axis=1)
    y = train_data_frame['Malware']
    
    # dataset is split into 70% for training and 30% for testing i.e 0.3
    # random_state is set to 100 for the shuffling process. It determines how the data set is
    # split into training and testing.
    # X_train and X_test are independent variables.
    # X_train & y_train are 70% of the dataset and X_test & y_test are 30% of the dataset. y_train is a dependent variable
    # that depends on X_train, while y_test is also a dependent variable that depends on X_test.
    # The values of y_train must be equal to X_train. Also, the value of y_test must be equal to X_test.
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 100)
    
    # feature scaling. 
    # This is essential for machine learning algorithms that calculate distances between
    # data. Scaling makes it easy for a model to learn and understand the problem.
    scale_feature(X_train, X_test)

    train_scores = []
    test_scores = []
    k = 20 # Number for K-nearest neighbors
    
    # A for loop to check for the best value of K from 1 to 20.
    for n_neighbors in range(1, k):
        knn_clf = KNeighborsClassifier(n_neighbors)
        knn_clf.fit(X_train, y_train)
        train_scores.append(knn_clf.score(X_train, y_train))
        test_scores.append(knn_clf.score(X_test, y_test))
    knn_visualize(train_scores, test_scores, k)
        
    print("K-Nearest Neigbors Prediction: {0:.2f}%\n".format(knn_clf.score(X_test, y_test) * 100))
    knn_classification_report(knn_clf, X_test, y_test)
    
if __name__ == '__main__':
    # First two lines reads in the dataset into train_data_frame and test_data_frame. 
    train_data_frame = pd.read_csv('dataset_malwares.csv', sep=',')
    test_data_frame = pd.read_csv('dataset_test.csv', sep=',')
    
    # call the knn function to train KNN classifier.
    knn(train_data_frame)